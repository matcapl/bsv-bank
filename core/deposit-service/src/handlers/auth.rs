// core/deposit-service/src/handlers/auth.rs
// Authentication endpoints (register, login)

use actix_web::{web, HttpResponse, Result};
use bsv_bank_common::{
    validate_paymail, JwtManager, LogContext, ServiceError,
    log_auth_attempt, log_validation_error,
};
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use sqlx::PgPool;
// use uuid::Uuid;

#[derive(Debug, Deserialize)]
pub struct RegisterRequest {
    pub paymail: String,
    pub password: String,
}

#[derive(Debug, Serialize)]
pub struct AuthResponse {
    pub token: String,
    pub paymail: String,
    pub expires_in: u64,
}

#[derive(Debug, Deserialize)]
pub struct LoginRequest {
    pub paymail: String,
    pub password: String,
}

pub struct AuthState {
    pub db_pool: PgPool,
    pub jwt_manager: JwtManager,
}

/// Register a new user
pub async fn register(
    data: web::Data<AuthState>,
    req: web::Json<RegisterRequest>,
    http_req: actix_web::HttpRequest,  // Changed this
) -> Result<HttpResponse> {
    let request_id = http_req
        .headers()
        .get("x-request-id")
        .and_then(|h| h.to_str().ok())
        .unwrap_or("unknown");
    let ctx = LogContext::new(request_id.to_string());

    // Validate paymail
    if let Err(e) = validate_paymail(&req.paymail) {
        log_validation_error(&ctx, "paymail", &req.paymail, &e.to_string());
        return Err(ServiceError::from(e).into());
    }

    // Validate password strength
    if req.password.len() < 8 {
        return Err(ServiceError::ValidationError(
            "Password must be at least 8 characters".to_string(),
        )
        .into());
    }

    // Hash password
    let mut hasher = Sha256::new();
    hasher.update(req.password.as_bytes());
    let password_hash = format!("{:x}", hasher.finalize());

    // Check if user already exists
    let existing_user = sqlx::query!(
        "SELECT paymail FROM users WHERE paymail = $1",
        req.paymail
    )
    .fetch_optional(&data.db_pool)
    .await
    .map_err(ServiceError::from)?;

    if existing_user.is_some() {
        return Err(ServiceError::Conflict("User already exists".to_string()).into());
    }

    // Create user (id auto-generated by database)
    sqlx::query!(
        "INSERT INTO users (paymail, password_hash, created_at) VALUES ($1, $2, NOW())",
        req.paymail,
        password_hash
    )

    .execute(&data.db_pool)
    .await
    .map_err(ServiceError::from)?;

    // Generate JWT token
    let token = data
        .jwt_manager
        .create_token(&req.paymail, vec!["read".to_string(), "write".to_string()], 24)
        .map_err(ServiceError::from)?;

    log_auth_attempt(&ctx, &req.paymail, true);

    Ok(HttpResponse::Ok().json(AuthResponse {
        token,
        paymail: req.paymail.clone(),
        expires_in: 86400, // 24 hours
    }))
}

/// Login existing user
pub async fn login(
    data: web::Data<AuthState>,
    req: web::Json<LoginRequest>,
    http_req: actix_web::HttpRequest,  // Changed this
) -> Result<HttpResponse> {
    let request_id = http_req
        .headers()
        .get("x-request-id")
        .and_then(|h| h.to_str().ok())
        .unwrap_or("unknown");
    let ctx = LogContext::new(request_id.to_string());

    // Hash password
    let mut hasher = Sha256::new();
    hasher.update(req.password.as_bytes());
    let password_hash = format!("{:x}", hasher.finalize());

    // Find user
    let user = sqlx::query!(
        "SELECT paymail, password_hash FROM users WHERE paymail = $1",
        req.paymail
    )
    .fetch_optional(&data.db_pool)
    .await
    .map_err(ServiceError::from)?;

    match user {
        Some(user) if user.password_hash == password_hash => {
            // Generate JWT token
            let token = data
                .jwt_manager
                .create_token(&req.paymail, vec!["read".to_string(), "write".to_string()], 24)
                .map_err(ServiceError::from)?;

            log_auth_attempt(&ctx, &req.paymail, true);

            Ok(HttpResponse::Ok().json(AuthResponse {
                token,
                paymail: req.paymail.clone(),
                expires_in: 86400,
            }))
        }
        _ => {
            log_auth_attempt(&ctx, &req.paymail, false);
            Err(ServiceError::Unauthorized.into())
        }
    }
}

/// Refresh token
pub async fn refresh_token(
    data: web::Data<AuthState>,
    http_req: actix_web::HttpRequest,
) -> Result<HttpResponse> {
    let auth_header = http_req
        .headers()
        .get("authorization")
        .and_then(|h| h.to_str().ok())
        .ok_or_else(|| ServiceError::Unauthorized)?;
        
    let token = auth_header
        .trim_start_matches("Bearer ")
        .to_string();

    let new_token = data
        .jwt_manager
        .refresh_token(&token, 24)
        .map_err(ServiceError::from)?;

    let claims = data
        .jwt_manager
        .verify_token(&new_token)
        .map_err(ServiceError::from)?;

    Ok(HttpResponse::Ok().json(AuthResponse {
        token: new_token,
        paymail: claims.sub,
        expires_in: 86400,
    }))
}

#[cfg(test)]
mod tests {
    use super::*;
    use actix_web::web;
    use bsv_bank_common::JwtManager;
    use sqlx::postgres::PgPoolOptions;

    async fn setup_test_pool() -> PgPool {
        let database_url = std::env::var("DATABASE_URL")
            .unwrap_or_else(|_| "postgres://localhost/bsv_bank_test".to_string());

        PgPoolOptions::new()
            .max_connections(1)
            .connect(&database_url)
            .await
            .expect("Failed to connect to test database")
    }

    #[actix_web::test]
    async fn test_register_validation() {
        let pool = setup_test_pool().await;
        let jwt_manager = JwtManager::new("test-secret".to_string());
        let state = web::Data::new(AuthState {
            db_pool: pool,
            jwt_manager,
        });

        let req = web::Json(RegisterRequest {
            paymail: "invalid-email".to_string(),
            password: "password123".to_string(),
        });

        let request_id = web::Header("test-request-id".to_string());
        let result = register(state, req, request_id).await;
        assert!(result.is_err());
    }

    #[actix_web::test]
    async fn test_password_length_validation() {
        let pool = setup_test_pool().await;
        let jwt_manager = JwtManager::new("test-secret".to_string());
        let state = web::Data::new(AuthState {
            db_pool: pool,
            jwt_manager,
        });

        let req = web::Json(RegisterRequest {
            paymail: "test@example.com".to_string(),
            password: "short".to_string(),
        });

        let request_id = web::Header("test-request-id".to_string());
        let result = register(state, req, request_id).await;
        assert!(result.is_err());
    }
}

